# 基本概念

## 语法

### 区分大小写

### 标识符

是指变量、函数、属性的名字，或者函数的参数

- 第一个字符必须是一个字母、下划线（\_）或一个美元符号（$）
- 其他字符可以是字母、下划线、美元符号或数字

> 不能把关键字、保留字、true、false 和 null 用作标识符

### 注释

// 或者 /\* \*/

### 严格模式

ECMAScript 5 引入了严格模式（strict mode）的概念
"use strict";

### 语句

ECMAScript 中的语句以一个分号结尾；如果省略分号，则由解析器确定语句的结尾  
加上这个分号可以避免很多错误（例如不完整的输入），开发人员也可以放心地通过删除多余的空格来压缩 ECMAScript 代码（代
码行结尾处没有分号会导致压缩错误）。另外，加上分号也会在某些情况下增进代码的性能，因为这样解析器就不必再花时间推测应该在哪里插入分号了

## 关键字和保留字

关键字:

```
break do instanceof typeof
case else new var
catch finally return void
continue for switch while
debugger function this with
default if throw
delete in try
```

保留字:(ECMA-262 第 3 版定义的全部保留字)

```
abstract enum int short
boolean export interface static
byte extends long super
char final native synchronized
class float package throws
const goto private transient
debugger implements protected volatile
double import public
```

第 5 版把在非严格模式下运行时的保留字缩减为下列这些：
class enum extends super
const export import
在严格模式下，第 5 版还对以下保留字施加了限制：
implements package public
interface private static
let protected yield

## 变量

ECMAScript 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。

## 数据类型

ECMAScript 中有 5 种简单数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number
和 String。
还有 1 种复杂数据类型——Object，Object 本质上是由一组无序的名值对组成的。

### typeof 操作符

typeof 是一个操作符而不是函数

- "undefined"——如果这个值未定义；
- "boolean"——如果这个值是布尔值；
- "string"——如果这个值是字符串；
- "number"——如果这个值是数值；
- "object"——如果这个值是对象或 null；
- "function"——如果这个值是函数

#### Undefined

Undefined 类型只有一个值，即特殊的 undefined。

对于尚未声明过的变量，只
能执行一项操作，即使用 typeof 操作符检测其数据类型（对未经声明的变量调用 delete 不会导致错
误，但这样做没什么实际意义，而且在严格模式下确实会导致错误）

对未初始化的变量执行 typeof 操作符会返回 undefined 值，而对未声明
的变量执行 typeof 操作符同样也会返回 undefined 值

#### Null

Null 类型是第二个只有一个值的数据类型，这个特殊的值是 null。

从逻辑角度来看，null 值表
示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回"object"的原因

如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null 而不是其他值。

实际上，undefined 值是派生自 null 值的，因此 ECMA-262 规定对它们的相等性测试要返回 true：  
alert(null == undefined); //true

#### Boolean

该类型只有两个字面值：true 和 false。

<table>
    <thead>
        <td>数据类型</td>
        <td>转换为true的值</td>
        <td>转换为false的值</td>
    </thead>
    <tbody>
        <tr>
            <td>Boolean</td>
            <td>true</td>
            <td>false</td>
        </tr>
        <tr>
            <td>String</td>
            <td>任何非空字符串</td>
            <td>""（空字符串）</td>
        </tr>
        <tr>
            <td>Number</td>
            <td>任何非零数字值（包括无穷大）</td>
            <td>0和NaN</td>
        </tr>
        <tr>
            <td>Object</td>
            <td>任何对象 </td>
            <td>null</td>
        </tr>
        <tr>
            <td>Undefined</td>
            <td>n/a（not applicable）</td>
            <td>undefined </td>
        </tr>
    </tbody>
</table>

#### Number

这种类型使用 IEEE754 格式来表示整数和浮点数值（浮点数值在某些语言中也被称为双精度数值）。为支持各种数值类型，ECMA-262 定义了不同的数值字面量格式。

- 整数: 十进制、八进制(070)、十六进制(0xA8)
- 浮点数值: 该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字
- NaN: 即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。

> 由于保存浮点数值需要的内存空间是保存整数值的两倍，因此 ECMAScript 会不失时机地将浮点数值转换为整数值。如果小数点后面没有跟任何数字，那么这个数值就可以作为整数值来保存。同样地，如果浮点数值本身表示的就是一个整数（如 1.0），那么该值也会被转换为整数

> 关于浮点数值计算会产生舍入误差的问题，有一点需要明确：这是使用基于 IEEE754 数值的浮点计算的通病，ECMAScript 并非独此一家；其他使用相同数值格式的语言也存在这个问题

> 0.1+0.2!=0.3  
> [JS 的 0.1+0.2 问题的探究](https://www.cnblogs.com/tony8/p/3455157.html)  
> [为什么 javascript 中 0.1 + 0.2 !== 0.3 为 True](https://segmentfault.com/q/1010000000137297)  
> 最常见的方法时设置一个误差范围值，通常称为“机械精度”，对于 javascript 这个值是 2^-52（2.220446049250313e-16）。从 es6 中该值定义在 Number.EPSILON 中，我们可以直接拿来用

> 在基于对象调用 isNaN()函数时，会首先调用对象的 valueOf()方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个返回值再调用 toString()方法，再测试返回值

Number()函数的转换规则：

- 如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。
- 如果是数字值只是简单的传入和返回。
- 如果是 null 值，返回 0
- 如果是 undefined，返回 NaN
- 如果是字符串，遵循下列规则：  
  1、 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即"1"会变成 1，"123"会变成 123，而"011"会变成 11（注意：前导的零被忽略了）；  
  2、如果字符串中包含有效的浮点格式，如"1.1"，则将其转换为对应的浮点数值（同样，也会忽
  略前导零）；  
  3、如果字符串中包含有效的十六进制格式，例如"0xf"，则将其转换为相同大小的十进制整数值；  
  4、如果字符串是空的（不包含任何字符），则将其转换为 0；  
  5、如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。
- 如果是对象，则调用对象的 valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN，则调用对象的 toString()方法，然后再次依照前面的规则转换返回的字符串值。

> 一元加操作符的操作与 Number()函数相同

> parseInt()函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt()就会返回 NaN；如果第一个字符是数字字符，parseInt()会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。parseInt()也能够识别出各种整数格式（即前面讨论的十进制、八进制和十六进制数）。
> parseInt()在解析八进制时，ES3 和 ES5 javascript 引擎解析会不一致，因此为这个函数指定第二个参数：转换时使用的基数（即多少进制）。

> parseFloat()也是从第一个字符（位置 0）开始解析每个字符。而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。parseFloat()与 parseInt()的第二个区别在于它始终都会忽略前导的零。parseFloat()只解析十进制值，因此它没有用第二个参数指定基
> 数的用法。

#### String

String 类型用于表示由零或多个 16 位 Unicode 字符组成的字符序列，即字符串。字符串可以由双
引号（"）或单引号（'）表示

##### 字符字面量

String 数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符，或者具有其
他用途的字符

\n 换行  
\t 制表  
\b 空格  
\r 回车  
\f 进纸  
\\ 斜杠  
\' 单引号（'），在用单引号表示的字符串中使用。例如：'He said, \'hey.\''  
\" 双引号（"），在用双引号表示的字符串中使用。例如："He said, \"hey.\""  
\xnn 以十六进制代码 nn 表示的一个字符（其中 n 为 0 ～ F）。例如，\x41 表示"A"  
\unnnn 以十六进制代码 nnnn 表示的一个 Unicode 字符（其中 n 为 0 ～ F）。例如，\u03a3 表示希腊字符 Σ

##### 字符串的特点

ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变
某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量

##### 转换为字符串

要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的 toString()方法  
转型函数 String()，这个函数能够将任何类型的值转换为字符串

String()函数遵循下列转换规则：

- 如果值有 toString()方法，则调用该方法（没有参数）并返回相应的结果；
- 如果值是 null，则返回"null"；
- 如果值是 undefined，则返回"undefined"。

#### Object

Object 的每个实例都具有下列属性和方法:

- constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是 Object()
- hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例
  的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例
  如：o.hasOwnProperty("name")）。
- isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型
- propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用 for-in 语句来枚举。与 hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定
- toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应
- toString()：返回对象的字符串表示。
- valueOf()：返回对象的字符串、数值或布尔值表示。通常与 toString()方法的返回值相同

## 操作符

ECMA-262 描述了一组用于操作数据值的操作符，包括算术操作符（如加号和减号）、位操作符、
关系操作符和相等操作符。ECMAScript 操作符的与众不同之处在于，它们能够适用于很多值，例如字
符串、数字值、布尔值，甚至对象。不过，在应用于对象时，相应的操作符通常都会调用对象的 valueOf()和（或）toString()方法，以便取得可以操作的值

### 一元操作符

++ -- + -

### 位操作符

位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。

对于有符号的整数，32 位中的前 31 位用于表示整数的值。第 32 位用于表示数值的符号：0 表示正数，1 表示负数。这个表示符号的位叫做符号位，符号位的值决定了其他位数值的格式。

纯二进制格式存储，31 位中的每一位都表示 2 的幂。第一位（叫做位 0）表示 20，第二位表示 21，以此类推。没有用到的位以 0 填充，即忽略不计。

负数同样以二进制码存储，但使用的格式是二进制补码。计算一个数值的二进制补码，需要经过下
列 3 个步骤：
(1) 求这个数值绝对值的二进制码（例如，要求 18 的二进制补码，先求 18 的二进制码）；  
(2) 求二进制反码，即将 0 替换为 1，将 1 替换为 0；  
(3) 得到的二进制反码加 1。

在 ECMAScript 中，当对数值应用位操作符时，后台会发生如下转换过程：64 位的数值被转换成 32
位数值，然后执行位操作，最后再将 32 位的结果转换回 64 位数值。这样，表面上看起来就好像是在操作 32 位数值，就跟在其他语言中以类似方式执行二进制操作一样。

### 布尔操作符

#### 逻辑非

逻辑非操作符由一个叹号（！）表示，可以应用于 ECMAScript 中的任何值。无论这个值是什么数据
类型，这个操作符都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再
对其求反。也就是说，逻辑非操作符遵循下列规则：

- 如果操作数是一个对象，返回 false；
- 如果操作数是一个空字符串，返回 true；
- 如果操作数是一个非空字符串，返回 false；
- 如果操作数是数值 0，返回 true；
- 如果操作数是任意非 0 数值（包括 Infinity），返回 false；
- 如果操作数是 null，返回 true；
- 如果操作数是 NaN，返回 true；
- 如果操作数是 undefined，返回 true。

> 逻辑非操作符也可以用于将一个值转换为与其对应的布尔值。而同时使用两个逻辑非操作符，实际
> 上就会模拟 Boolean()转型函数的行为。其中，第一个逻辑非操作会基于无论什么操作数返回一个布尔值，而第二个逻辑非操作则对该布尔值求反，于是就得到了这个值真正对应的布尔值。

#### 逻辑与

逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况
下，逻辑与操作就不一定返回布尔值；此时，它遵循下列规则：

- 如果第一个操作数是对象，则返回第二个操作数；
- 如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该
  对象；
- 如果两个操作数都是对象，则返回第二个操作数；
- 如果有一个操作数是 null，则返回 null；
- 如果有一个操作数是 NaN，则返回 NaN；
- 如果有一个操作数是 undefined，则返回 undefined。

> 逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。对于逻辑与操作而言，如果第一个操作数是 false，则无论第二个操作数是什么值，结果都不再可能是 true 了

#### 逻辑或

与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值；此时，它遵循下
列规则：

- 如果第一个操作数是对象，则返回第一个操作数；
- 如果第一个操作数的求值结果为 false，则返回第二个操作数；
- 如果两个操作数都是对象，则返回第一个操作数；
- 如果两个操作数都是 null，则返回 null；
- 如果两个操作数都是 NaN，则返回 NaN；
- 如果两个操作数都是 undefined，则返回 undefined。

> 与逻辑与操作符相似，逻辑或操作符也是短路操作符。也就是说，如果第一个操作数的求值结果为 true，就不会对第二个操作数求值了。

#### 乘性操作符

#### 加性操作符

##### 加法

如果两个操作符都是数值，执行常规的加法计算，然后根据下列规则返回结果

- 如果有一个操作数是 NaN，则结果是 NaN；
- 如果是 Infinity 加 Infinity，则结果是 Infinity；
- 如果是-Infinity 加-Infinity，则结果是-Infinity；
- 如果是 Infinity 加-Infinity，则结果是 NaN；
- 如果是+0 加+0，则结果是+0；
- 如果是 \-0 加 \-0，则结果是 \-0
- 如果是+0 加 \-0，则结果是+0

不过，如果有一个操作数是字符串，那么就要应用如下规则：

- 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；
- 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来

> 如果有一个操作数是对象、数值或布尔值，则调用它们的 toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于 undefined 和 null，则分别调用 String()函数并取得字符串"undefined"和"null"。

##### 减法

与加法操作符类似，ECMAScript 中的减法操作符在处理各种数据类型转换时，同样需要遵循一些特殊规则，如下所示：

- 如果两个操作符都是数值，则执行常规的算术减法操作并返回结果；
- 如果有一个操作数是 NaN，则结果是 NaN；
- 如果是 Infinity 减 Infinity，则结果是 NaN；
- 如果是-Infinity 减-Infinity，则结果是 NaN；
- 如果是 Infinity 减-Infinity，则结果是 Infinity；
- 如果是-Infinity 减 Infinity，则结果是-Infinity；
- 如果是+0 减+0，则结果是+0；
- 如果是+0 减\-0，则结果是\-0；
- 如果是\-0 减\-0，则结果是+0；
- 如果有一个操作数是字符串、布尔值、null 或 undefined，则先在后台调用 Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN，则减法的结果就是 NaN；
- 如果有一个操作数是对象，则调用对象的 valueOf()方法以取得表示该对象的数值。如果得到的值是 NaN，则减法的结果就是 NaN。如果对象没有 valueOf()方法，则调用其 toString()方法并将得到的字符串转换为数值

#### 关系操作符

小于（<）、大于（>）、小于等于（<=）和大于等于（>=）

- 如果两个操作数都是数值，则执行数值比较。
- 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。
- 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。
- 如果一个操作数是对象，则调用这个对象的 valueOf()方法，用得到的结果按照前面的规则执
  行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面
  的规则执行比较。
- 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较

#### 相等操作符

#### 条件操作符

#### 赋值操作符

#### 逗号操作符

## 流控制语句

### if 语句

### do-while 语句

### while 语句

### for 语句

### for in 语句

可以用来枚举对象的属性

### label 语句

使用 label 语句可以在代码中添加标签，以便将来使用

### break 和 continue 语句

break 语句会立即退出循环，强制继续执行循环后面的语句。而 continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行

### with 语句

with 语句的作用是将代码的作用域设置到一个特定的对象中

### switch 语句

switch 语句与 if 语句的关系最为密切，而且也是在其他语言中普遍使用的一种流控制语句。

> switch 语句在比较值时使用的是全等操作符，因此不会发生类型转换（例如，字符串"10"不等于数值 10）。

## 函数

ECMAScript 中的所有参数传递的都是值，不可能通过引用传递

ECMAScript 函数不能像传统意义上那样实现重载

无须指定函数的返回值，因为任何 ECMAScript 函数都可以在任何时候返回任何值  
未指定返回值的函数返回的是一个特殊的 undefined 值


