# 浏览器架构及 event loop

## 浏览器 node

event loop 在浏览器端和 node 中不一样  
览器的 Event Loop 是在[html5 中的规范](https://www.w3.org/TR/html5/webappapis.html#event-loops)中明确定义的。  
NodeJS 的 Event Loop 是基于 libuv 实现的。

## 进程 线程

进程是资源分配的最小单位，线程是 CPU 调度的最小单位。每个进程都有自己的一部分独立的系统资源，彼此是隔离的。为了能使不同的进程互相访问资源并进行协调工作，才有了进程间通信。

- 进程间通信（IPC，Inter-Process Communication）
  指至少两个进程或线程间传送数据或信号的一些技术或方法。

![进程与线程的资源共享关系](https://images2018.cnblogs.com/news/1/201711/1-20171129153632862-1604985395.png)

[进程与线程的一个简单解释-阮一峰](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)  
[进程与线程的一个简单解释](https://segmentfault.com/a/1190000005884656)
[以操作系统的角度述说线程与进程](https://kb.cnblogs.com/page/531409/)

### 浏览器内的进程

浏览器是多进程的，之所以浏览器能够运行，是因为系统给浏览器分配了资源，如 cpu、内存等。

#### 浏览器多进程模型

优势：

- 避免因单个页面的不响应或者崩溃而影响整个浏览器的稳定，特别是对用户界面的影响
- 第三方插件崩溃时不会影响页面或者浏览器的稳定性
- 方便了安全模型的实施，沙箱模型就是基于多进程架构

chromium 浏览器的多进程模型：
![chromium 浏览器的多进程模型](https://img-blog.csdn.net/20160510000530303)

- Browser 进程：浏览器的主进程（负责协调、主控），只有一个。负责游览器界面的显示、各个页面的管理，网络资源的管理，下载等，是所有其他类型进程的祖先，负责它们的创建和销毁等；
- Render 进程：浏览器渲染进程（浏览器内核），内部是多线程的，负责页面渲染、脚本执行、事件处理等，可能有多个，具体个数允许配置；
- NPAPI 插件进程：是为 NPAPI 类型的插件而创建的，其创建的基本原则是每种类型的插件只会被创建一次，而且仅当使用时才会创建，当有多个网页要使用同一个类型的插件的时候，插件进程是被共享的；
- GPU 进程：最多只有一个，并且仅当 GPU 硬件加速打开的时候才会被创建，主要用于对 3D 图形加速调用的实现；
- Pepper 插件进程：同 NPAPI 进程，不同是是为 Pepper 插件而创建的进程；

chromium 多线程模型：  
![chromium多线程模型](https://img-blog.csdn.net/20160510232034145)

- Browser 进程收到用户的请求，首先由 UI 线程处理，而且将相应的任务转给 IO 线程，他随即将该任务传递给 Render 进程；
- Render 进程的 IO 线程经过简单解释后交给渲染线程，渲染线程接收请求，加载网页并渲染网页，这其中可能需要 Browser 进程获取资源和需要 GPU 进程来帮助渲染，最后 Render 进程将结果由 IO 线程传递给 Browser 进程；
- Browser 进程接收到结果并将结果绘制出来；

[浅谈浏览器多进程与 JS 线程](https://segmentfault.com/a/1190000013083967)  
[webkit 架构和模块](https://blog.csdn.net/Steward2011/article/details/51319298)

#### 浏览器内核

浏览器内核，就是渲染进程（render 进程），页面的渲染，js 的执行，事件的循环，该进程下有多个线程

![浏览器内核](https://segmentfault.com/img/bV23V5?w=287&h=577)

1、图形用户界面 GUI 渲染线程

- 负责渲染浏览器界面，包括解析 HTML、CSS、构建 DOM 树、Render 树、布局与绘制等
- 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行

2、js 引擎线程

- JS 内核，也称 JS 引擎，负责处理执行 javascript 脚本
- 等待任务队列的任务的到来，然后加以处理，浏览器无论什么时候都只有一个 JS 引擎在运行 JS 程序

3、事件触发线程

- 来自浏览器内核的其他线程,如鼠标点击等，控制交互，响应用户

4、定时触发器线程

- setInterval 与 setTimeout 所在线程
- 定时计时器并不是由 JS 引擎计时的，因为如果 JS 引擎是单线程的，如果 JS 引擎处于堵塞状态，那会影响到计时的准确

5、异步 HTTP 请求线程

- 在 XMLHttpRequest 在连接后新启动的一个线程

#### 浏览器内核中线程之间的关系

##### GUI 渲染进程与 JS 引擎线程互斥

因为 JS 引擎可以修改 DOM 树，那么如果 JS 引擎在执行修改了 DOM 结构的同时，GUI 线程也在渲染页面，那么这样就会导致渲染线程获取的 DOM 的元素信息可能与 JS 引擎操作 DOM 后的结果不一致。为了防止这种现象，GUI 线程与 JS 线程需要设计为互斥关系，当 JS 引擎执行的时候，GUI 线程需要被冻结，但是 GUI 的渲染会被保存在一个队列当中，等待 JS 引擎空闲的时候执行渲染。  
由此也可以推出，如果 JS 引擎正在进行 CPU 密集型计算，那么 JS 引擎将会阻塞，长时间不空闲，导致渲染进程一直不能执行渲染，页面就会看起来卡顿卡顿的，渲染不连贯，所以，要尽量避免 JS 执行时间过长。

##### JS 引擎线程与事件触发线程、定时触发器线程、异步 HTTP 请求线程

事件触发线程、定时触发器线程、异步 HTTP 请求线程三个线程有一个共同点，那就是使用回调函数的形式，当满足了特定的条件，这些回调函数会被执行。这些回调函数被浏览器内核理解成事件，在浏览器内核中拥有一个事件队列，这三个线程当满足了内部特定的条件，会将这些回调函数添加到事件队列中，等待 JS 引擎空闲执行。例如异步 HTTP 请求线程，线程如果检测到请求的状态变更，如果设置有回调函数，回调函数会被添加事件队列中，等待 JS 引擎空闲了执行。  
但是，JS 引擎对事件队列（宏任务）与 JS 引擎内的任务（微任务）执行存在着先后循序，当每执行完一个事件队列的时间，JS 引擎会检测内部是否有未执行的任务，如果有，将会优先执行（微任务）。

## js 单线程

js 单线程  
Event Loop 是 javascript 的执行机制

## 同步 异步

## 宏任务 微任务

- 宏任务 (setTimeout, setInterval, setImmediate(ie, node), MessageChannel)
- 微任务 (promise.then, MutationObserver, process.nextTick (Node))

## 栈 队列

- 栈 先进后出
- 队列 先进先出

代码在栈中执行

函数的调用栈 作用域的销毁和创建

[event loop](https://pic3.zhimg.com/v2-fdd9322a0cabafa7d3461e5d25718586_1200x500.jpg)
