# 并发模型与事件循环

[并发模型与事件循环](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop)

JavaScript 的并发模型基于"事件循环"。

## 运行时概念

![运行时概念](https://developer.mozilla.org/files/4617/default.svg)

### 栈

函数调用形成了一个栈帧

### 堆

对象被分配在一个堆中，即用以表示一个大部分非结构化的内存区域

### 队列

一个 javascript 运行时包含了一个待处理的消息队列，每一个消息都有一个为了处理这个消息相关联的函数。

在事件循环期间的某个时刻，运行时总是从最先进入队列的一个消息开始处理队列中的消息。正因为如此，这个消息就会被移除队列，并将其作为输入参数调用与之关联的函数。为了使用这个函数，调用一个函数总是会为其创造一个新的栈帧。

函数的处理会一致进行直到执行栈再次为空，然后事件循环将会处理队列中的下一个消息。

## 事件循环

之所以称为事件循环，是因为它经常被用于类似如下的方式来实现：

```
while(queue.wairForMessage()){
    queue.processNextMessage()
}
```

如果当前没有任何消息 queue.waitForMessage 会等待同步消息到达。

### 执行至完成

每一个消息完整的被执行后，其他消息才会被执行。每当一个函数运行时，它就不能被抢占，并且在其他代码运行之前完全运行（且可以修改此函数操作的数据）。

缺点：当一个消息需要太长时间才能完成，web 应用无法处理用户交互，例如点击或滚动。浏览器用“程序需要过长时间运行”的对话框来缓解这个问题。一个很好的做法是使消息处理缩短，如果可能，将一个消息裁剪成几个消息。

### 添加消息

在浏览器里，当一个事件出现且有一个事件监听器被绑定时，消息会被随时添加。如果没有事件监听器，事件会丢失。所以点击一个附带点击事件处理函数的元素会添加一个消息。其它事件亦然。

调用 setTimeout 函数会在一个时间段过去后在队列中添加一个消息。这个时间段作为函数的第二个参数被传入,时间参数的值代表了消息被实际加入到队列的最小延迟时间。如果队列中没有其它消息，消息会被马上处理。但是，如果有其它消息，setTimeout 消息必须等待其它消息处理完。因此第二个参数仅仅表示最少的时间 而非确切的时间。

### 零延迟

零延迟并不是意味着回调会立即执行。在零延迟调用 setTimeout 时，其并不是过了给定的时间间隔后就马上执行回调函数。其等待的时间基于队列里正在等待的消息数量。

### 多个运行时互相通信

一个 web worker 或者一个跨域的 iframe 都有自己的栈，堆和消息队列。两个不同的运行时只能通过 postMessage 方法进行通信。如果后者侦听到 message 事件，则此方法会向其他运行时添加消息。

## 永不阻塞

javascript 事件循环模型永不阻塞， 处理 I/O 通常通过事件和回调来执行，所以当一个应用正等待 IndexedDB 查询返回或者一个 XHR 请求返回时，它仍然可以处理其它事情，如用户输入。
